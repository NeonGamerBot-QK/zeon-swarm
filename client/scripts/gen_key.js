// a server needs keys! share keys! trade keys!
// constants
let isServer = false;
// end constants
const { writeFileSync, existsSync } = require("fs");
const os = require("os");
const openpgp = require("openpgp");
if (existsSync("./data/client.pub") || existsSync("./data/client.key")) {
  console.log(
    `Keys exist already!, if you want to replace them remove the old ones!!`,
  );
  return;
}

function generateCrypticName() {
  const prefixes = [
    "Echo",
    "Null",
    "Silent",
    "Crimson",
    "Hidden",
    "Obsidian",
    "Lunar",
    "Phantom",
    "Eternal",
    "Neon",
    "Aether",
    "Void",
    "Iron",
    "Shadow",
    "Glass",
    "Wired",
    "Signal",
    "Solar",
  ];

  const middles = [""];

  const suffixes = [
    "Cipher",
    "Veil",
    "Horizon",
    "Code",
    "Fragment",
    "Node",
    "Origin",
    "Pulse",
    "Pattern",
    "Construct",
    "Bloom",
    "Shard",
    "Frame",
    "Mirror",
  ];

  // randomly decide number of words: 1, 2, or 3
  const numWords = Math.ceil(Math.random() * 3);

  if (numWords === 1) {
    // Single mysterious word
    return suffixes[Math.floor(Math.random() * suffixes.length)];
  } else if (numWords === 2) {
    // Adjective + noun
    return `${prefixes[Math.floor(Math.random() * prefixes.length)]} ${
      suffixes[Math.floor(Math.random() * suffixes.length)]
    }`;
  } else {
    // 3-word phrase (e.g. "Echo of Shard")
    return `${prefixes[Math.floor(Math.random() * prefixes.length)]} ${
      middles[Math.floor(Math.random() * middles.length)]
    } ${suffixes[Math.floor(Math.random() * suffixes.length)]}`;
  }
}

let [name, email] = process.argv.slice(2);
if (!name || !email) {
  name = generateCrypticName();
  if (isServer) name += " [server]";
  if (isServer) email = `${name.split(/ +/).join("-")}@${os.hostname()}`;
  else email = `${name.split(/ +/).join("-")}@${os.platform()}`;
  // console.log(`Provide an name and email via the cli, eg: "Name here" machine-name@device`)
  // return;
  console.warn(
    `[WARNING] no name or email using autogenerated "${name}" ${email}`,
  );
}
(async () => {
  if (!existsSync("./data")) require("fs").mkdirSync("./data");
  const { privateKey, publicKey, revocationCertificate } =
    await openpgp.generateKey({
      type: "ecc", // Type of the key, defaults to ECC
      curve: "curve25519", // ECC curve name, defaults to curve25519
      userIDs: [{ name, email }], // you can pass multiple user IDs
      format: "armored", // output key format, defaults to 'armored' (other options: 'binary' or 'object')
    });

  console.log(privateKey); // '-----BEGIN PGP PRIVATE KEY BLOCK ... '
  console.log(publicKey); // '-----BEGIN PGP PUBLIC KEY BLOCK ... '
  console.log(revocationCertificate); // '-----BEGIN PGP PUBLIC KEY BLOCK ... '
  writeFileSync("./data/client.pub", publicKey);
  writeFileSync("./data/client.key", privateKey);
  writeFileSync("./data/revocation.crt", revocationCertificate);
  console.log(
    `Keys generated and saved to ./data/client.pub and ./data/client.key`,
  );
})();
